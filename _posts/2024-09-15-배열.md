---
title: 배열(Array) 
date: 2024-09-15 
categories: [CS, 자료구조]
tags: [자료구조]
---
## 정의
사전적 정의는 '일정한 차례나 간격에 따라 벌여 놓음'이다. 즉, 배열은 차례(순서)와 관련된 기본적인 선형 자료구조이다.  
인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합을 의미한다.  
  
## 특징
원소의 메모리 공간의 물리적인 위치를 '순서'적으로 결정하는 특징이 있으며, 원소들이 모두 같은 자료형과 같은 크기의 기억 공간을 가진다. 배열의 인덱스 값을 이용해서 원소값에 접근하기 때문에 직접 접근이 가능해진다.  
  
가장 중요한 특징은 추상화된 논리적인 배열의 인덱스 순서값은 실제 메모리의 구체화된 물리적 주소의 순서와 동일 하다는 것이다.  

## 배열의 생성과 종류
우리는 C 나 Swift로 배열을 생성해보자.
```c
int int_array[3] = {1, 2, 3};
```
```swift
let intArray: [Int] = [1, 2, 3]
```
![](/assets/img/post-image/20240915PostArray/array1.png)

위 코드를 작성하게 되면 그림과 같은 형태로 배열은 생성이 되게 된다.
### 1차원 배열
한 줄짜리 배열을 의미하며, 하나의 인덱스로 구분되는 배열을 말한다.  
메모리의 비트마다 주소가 존재한다. 예를 들어 배열의 인덱스마다 크기가 8비트로 정해진다고 하면 8비트를 묶는 것이다.
1차원 배열이 a[]가 존재하고 a[]의 메모리 시작 주소를 A라고 가정하면,  a[i]의 메모리 저장 주소는 [A + i * k] 가 된다.  

![](/assets/img/post-image/20240915PostArray/array2.png)
  
### 행렬의 배열 표현(2차원 배열)
행렬을 컴퓨터에서 표현하기에는 2차원 배열이 적합하다.  
  
5  2  6  2  
7  2  0  0  
0  1  1  9  
  
|5|2|6|2|  
|---|---|---|---|  
|7|2|0|0|  
|0|1|1|9|  
  
이와 같은 행렬이 있다면 2차원 배열을 활용할 수 있다.  
  
![](/assets/img/post-image/20240915PostArray/array3.png)
행렬의 2차원 배열 표현은 위 그림과 같다.  

### 2차원 배열의 할당 방식
2차원 배열은 메모리에 2가지 방식으로 할당할 수가 있다.
1. 행 우선 할당
2. 열 우선 할당
  
  
- 행 우선 할당
![](/assets/img/post-image/20240915PostArray/array4.png)
위 그림처럼 가로의 1차원 배열 단위로 메모리 영역을 우선 할당하게 된다.  
  
- 열 우선 할당
![](/assets/img/post-image/20240915PostArray/array5.png)
위 그림처럼 세로의 1차원 배열 단위로 메모리 영역을 우선 할당하게 된다.  
  
### 희소행렬
원소값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많은 행렬이다.  
희소행렬을 위처럼 행이나 열 우선 할당으로 할당을 하게 되면 사용하지 않는 메모리를 점유하기 때문에 비효율적이게 된다.
![](/assets/img/post-image/20240915PostArray/array6.png)
위 그림처럼 희소행렬을 행, 열, 값의 정보를 저장하게 된다.  
일반적으로 배열끼리의 연산은 저렇게 동일한 위치를 꺼내와서 더하고 빼고 하는데 지금 희소행렬은 그럴 수가 없기 때문에 따로 연산을 구현해주어야 한다. 여기서 하나의 법칙이 생기게 되는데 메모리 성능이 올라가면 연산이 복잡해지기 때문에 연산 시간이 더 걸리고, 메모리 성능이 낮아지면 연산 시간은 덜 걸리게 된다.

### 배열의 시간 복잡도
  
|Operation|Average Case|Worst case|  
|---|---|---|  
|read|O(1)|O(1)|  
|insert|O(n)|O(n)|  
|delete|O(n)|O(n)|  
|search|O(n)|O(n)|  
  
### 배열의 장점과 단점
>장점
{: .prompt-tip}
- 인덱스를 이용한 접근이 가능하기 때문에 모든 요소에 빠르게 접근이 가능함.
- 추상화된 인덱스와 물리적인 메모리 주소의 순서가 동일해서 코드 이해도가 높고 쉽게 사용 가능하다.

>단점 
{: .prompt-warning}
- 정적 크기의 배열은 정적 메모리 때문에 크기 변경이 불가능하다.
- 중간에 특정 요소를 삽입하거나 삭제하는 경우, 항상 메모리가 순차적으로 이어져야 하기 때문에 모든 요소들의 이동이 필요하다 그렇기 때문에 비용이 많이 들게 된다.
